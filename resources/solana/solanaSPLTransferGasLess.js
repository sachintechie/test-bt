"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transferSPLToken = transferSPLToken;
exports.getOrCreateAssociatedTokenAccount = getOrCreateAssociatedTokenAccount;
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const CubeSignerClient_1 = require("../cubist/CubeSignerClient");
const solanaFunctions_1 = require("./solanaFunctions");
const dbFunctions_1 = require("../db/dbFunctions");
const env = {
    SignerApiRoot: process.env["CS_API_ROOT"] ?? "https://gamma.signer.cubist.dev"
};
async function transferSPLToken(senderWalletAddress, receiverWalletAddress, amount, decimalPrecision, oidcToken, chainType, contractAddress, tenant, cubistOrgId) {
    try {
        const connection = await (0, solanaFunctions_1.getSolConnection)();
        // 1. Collect values from events
        const mintAddress = new web3_js_1.PublicKey(contractAddress);
        //let sendingAmount = parseFloat(amount.toString());
        console.log("decimalPrecision", decimalPrecision);
        let LAMPORTS_PER_SPLTOKEN = 10 ** decimalPrecision;
        console.log("LAMPORTS_PER_SPLTOKEN", LAMPORTS_PER_SPLTOKEN);
        const sendingAmount = amount * LAMPORTS_PER_SPLTOKEN;
        console.log("Sending Amount", sendingAmount);
        console.log("Amount", amount);
        const recipientPublicKey = new web3_js_1.PublicKey(receiverWalletAddress);
        // 2. Get the oidcClient key from oidcToken
        const oidcClient = await (0, CubeSignerClient_1.oidcLogin)(env, cubistOrgId, oidcToken, ["sign:*"]);
        if (!oidcClient) {
            return {
                trxHash: null,
                error: "Please send a valid identity token for verification"
            };
        }
        const cubistConfig = await (0, dbFunctions_1.getCubistConfig)(tenant.id);
        if (cubistConfig == null) {
            return {
                transaction: null,
                error: "Cubist Configuration not found for the given tenant"
            };
        }
        const keys = await oidcClient.sessionKeys();
        const senderKey = keys.filter((key) => key.materialId === senderWalletAddress)[0];
        const senderPublicKey = new web3_js_1.PublicKey(senderKey.materialId);
        // 3. Get the payer key
        const payerKey = await (0, CubeSignerClient_1.getPayerCsSignerKey)(chainType, tenant.id);
        if (payerKey.key == null) {
            return {
                trxHash: null,
                error: payerKey.error
            };
        }
        const payerPublicKey = new web3_js_1.PublicKey(payerKey.key.materialId);
        //Check sol balance on payer address
        const payerSolBalance = await connection.getBalance(payerPublicKey);
        if (payerSolBalance < 0.05) {
            return {
                trxHash: null,
                error: "Insufficient balance in payer account"
            };
        }
        // 4. Get or create the associated token accounts for the sender and recipient
        const senderTokenAccount = await getOrCreateAssociatedTokenAccount(connection, payerKey.key, mintAddress, senderPublicKey);
        const recipientTokenAccount = await getOrCreateAssociatedTokenAccount(connection, payerKey.key, mintAddress, recipientPublicKey);
        // 5. Create a transaction to transfer tokens
        const transaction = new web3_js_1.Transaction().add((0, spl_token_1.createTransferInstruction)(senderTokenAccount.address, recipientTokenAccount.address, senderPublicKey, sendingAmount // Amount of tokens to transfer (in smallest unit of the token, e.g., for SPL tokens with 6 decimals, 1e6 represents 1 token)
        ));
        // 6.Sign the transaction with the sender's keypair,Set the fee payer to the payer's public key
        transaction.feePayer = payerPublicKey;
        // 7.Specify the recent blockhash
        const { blockhash } = await connection.getRecentBlockhash();
        transaction.recentBlockhash = blockhash;
        // 8.Sign the transaction with payer
        const base64Payer = transaction.serializeMessage().toString("base64");
        // sign using the well-typed solana end point (which requires a base64 serialized Message)
        const respPayer = await payerKey.key.signSolana({ message_base64: base64Payer });
        const sigPayer = respPayer.data().signature;
        const sigBytesPayer = Buffer.from(sigPayer.slice(2), "hex");
        transaction.addSignature(payerPublicKey, sigBytesPayer);
        // 9.Sign the transaction with sender
        const base64Sender = transaction.serializeMessage().toString("base64");
        // sign using the well-typed solana end point (which requires a base64 serialized Message)
        const respSender = await senderKey.signSolana({ message_base64: base64Sender });
        const sigSender = respSender.data().signature;
        const sigBytesSender = Buffer.from(sigSender.slice(2), "hex");
        transaction.addSignature(senderPublicKey, sigBytesSender);
        console.log("Transaction", transaction);
        // 10.Send the transaction
        const txHash = await connection.sendRawTransaction(transaction.serialize());
        await connection.confirmTransaction(txHash);
        console.log(`txHash: ${txHash}`);
        return { trxHash: txHash, error: null };
    }
    catch (e) {
        return { trxHash: null, error: e };
    }
}
/**
 * Create an associated token account for a given mint and owner
 * @param connection
 * @param mint
 * @param owner
 * @param allowOwnerOffCurve
 * @param payerKey
 * @param programId
 * @param associatedTokenProgramId
 */
const createAssociatedTokenAccount = async (connection, mint, owner, allowOwnerOffCurve = false, payerKey, programId = spl_token_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID) => {
    const associatedToken = (0, spl_token_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
    const transaction = new web3_js_1.Transaction().add((0, spl_token_1.createAssociatedTokenAccountInstruction)(new web3_js_1.PublicKey(payerKey.materialId), associatedToken, owner, mint, programId, associatedTokenProgramId));
    transaction.feePayer = new web3_js_1.PublicKey(payerKey.materialId);
    const { blockhash } = await connection.getRecentBlockhash();
    transaction.recentBlockhash = blockhash;
    const base64 = transaction.serializeMessage().toString("base64");
    const resp = await payerKey.signSolana({ message_base64: base64 });
    const sig = resp.data().signature;
    const sigBytes = Buffer.from(sig.slice(2), "hex");
    transaction.addSignature(new web3_js_1.PublicKey(payerKey.materialId), sigBytes);
    const txHash = await connection.sendRawTransaction(transaction.serialize());
    console.log(`txHash: ${txHash}`);
};
/**
 * Get or create an associated token account for a given mint and owner
 * @param connection
 * @param payer
 * @param mint
 * @param owner
 * @param allowOwnerOffCurve
 * @param commitment
 * @param programId
 * @param associatedTokenProgramId
 */
async function getOrCreateAssociatedTokenAccount(connection, payer, mint, owner, allowOwnerOffCurve = false, commitment, programId = spl_token_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
    const associatedToken = (0, spl_token_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.
    // Sadly we can't do this atomically.
    let account;
    try {
        account = await (0, spl_token_1.getAccount)(connection, associatedToken, commitment, programId);
    }
    catch (error) {
        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,
        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the
        // TokenInvalidAccountOwnerError in this code path.
        if (error instanceof spl_token_1.TokenAccountNotFoundError || error instanceof spl_token_1.TokenInvalidAccountOwnerError) {
            // As this isn't atomic, it's possible others can create associated accounts meanwhile.
            try {
                await createAssociatedTokenAccount(connection, mint, owner, false, payer);
            }
            catch (error) {
                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected
                // instruction error if the associated account exists already.
            }
            // Now this should always succeed
            account = await (0, spl_token_1.getAccount)(connection, associatedToken, commitment, programId);
        }
        else {
            throw error;
        }
    }
    if (!account.mint.equals(mint))
        throw new spl_token_1.TokenInvalidMintError();
    if (!account.owner.equals(owner))
        throw new spl_token_1.TokenInvalidOwnerError();
    return account;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29sYW5hU1BMVHJhbnNmZXJHYXNMZXNzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic29sYW5hU1BMVHJhbnNmZXJHYXNMZXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBdUJBLDRDQWtIQztBQXlERCw4RUF5Q0M7QUEzT0QsNkNBQXNGO0FBQ3RGLGlEQVkyQjtBQUUzQixpRUFBNEU7QUFDNUUsdURBQXFEO0FBRXJELG1EQUFvRDtBQUNwRCxNQUFNLEdBQUcsR0FBUTtJQUNmLGFBQWEsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLGFBQWEsQ0FBQyxJQUFJLGlDQUFpQztDQUMvRSxDQUFDO0FBRUssS0FBSyxVQUFVLGdCQUFnQixDQUNwQyxtQkFBMkIsRUFDM0IscUJBQTZCLEVBQzdCLE1BQWMsRUFDZCxnQkFBd0IsRUFDeEIsU0FBaUIsRUFDakIsU0FBaUIsRUFDakIsZUFBdUIsRUFDdkIsTUFBYyxFQUNkLFdBQW1CO0lBRW5CLElBQUksQ0FBQztRQUNILE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBQSxrQ0FBZ0IsR0FBRSxDQUFDO1FBRTVDLGdDQUFnQztRQUNoQyxNQUFNLFdBQVcsR0FBRyxJQUFJLG1CQUFTLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDbkQsb0RBQW9EO1FBQ3BELE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUNsRCxJQUFJLHFCQUFxQixHQUFHLEVBQUUsSUFBSSxnQkFBZ0IsQ0FBQztRQUNuRCxPQUFPLENBQUMsR0FBRyxDQUFDLHVCQUF1QixFQUFFLHFCQUFxQixDQUFDLENBQUM7UUFFNUQsTUFBTSxhQUFhLEdBQUcsTUFBTSxHQUFHLHFCQUFxQixDQUFDO1FBQ3JELE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDN0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFOUIsTUFBTSxrQkFB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LEtBQUssWUFBWSxxQ0FBeUIsSUFBSSxLQUFLLFlBQVkseUNBQTZCLEVBQUUsQ0FBQztZQUNqRyx1RkFBdUY7WUFDdkYsSUFBSSxDQUFDO2dCQUNILE1BQU0sNEJBQTRCLENBQUMsVUFBVSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQzVFLENBQUM7WUFBQyxPQUFPLEtBQWMsRUFBRSxDQUFDO2dCQUN4QiwrRkFBK0Y7Z0JBQy9GLDhEQUE4RDtZQUNoRSxDQUFDO1lBRUQsaUNBQWlDO1lBQ2pDLE9BQU8sR0FBRyxNQUFNLElBQUEsc0JBQVUsRUFBQyxVQUFVLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUNqRixDQUFDO2FBQU0sQ0FBQztZQUNOLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQztJQUNILENBQUM7SUFFRCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO1FBQUUsTUFBTSxJQUFJLGlDQUFxQixFQUFFLENBQUM7SUFDbEUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUFFLE1BQU0sSUFBSSxrQ0FBc0IsRUFBRSxDQUFDO0lBRXJFLE9BQU8sT0FBTyxDQUFDO0FBQ2pCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25uZWN0aW9uLCBUcmFuc2FjdGlvbiwgUHVibGljS2V5LCB0eXBlIENvbW1pdG1lbnQgfSBmcm9tIFwiQHNvbGFuYS93ZWIzLmpzXCI7XG5pbXBvcnQge1xuICBBU1NPQ0lBVEVEX1RPS0VOX1BST0dSQU1fSUQsXG4gIGNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnRJbnN0cnVjdGlvbixcbiAgY3JlYXRlVHJhbnNmZXJJbnN0cnVjdGlvbixcbiAgZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzc1N5bmMsXG4gIFRPS0VOX1BST0dSQU1fSUQsXG4gIFRva2VuQWNjb3VudE5vdEZvdW5kRXJyb3IsXG4gIFRva2VuSW52YWxpZEFjY291bnRPd25lckVycm9yLFxuICBUb2tlbkludmFsaWRNaW50RXJyb3IsXG4gIFRva2VuSW52YWxpZE93bmVyRXJyb3IsXG4gIEFjY291bnQsXG4gIGdldEFjY291bnRcbn0gZnJvbSBcIkBzb2xhbmEvc3BsLXRva2VuXCI7XG5pbXBvcnQgKiBhcyBjcyBmcm9tIFwiQGN1YmlzdC1sYWJzL2N1YmVzaWduZXItc2RrXCI7XG5pbXBvcnQgeyBvaWRjTG9naW4sIGdldFBheWVyQ3NTaWduZXJLZXkgfSBmcm9tIFwiLi4vY3ViaXN0L0N1YmVTaWduZXJDbGllbnRcIjtcbmltcG9ydCB7IGdldFNvbENvbm5lY3Rpb24gfSBmcm9tIFwiLi9zb2xhbmFGdW5jdGlvbnNcIjtcbmltcG9ydCB7IHRlbmFudCB9IGZyb20gXCIuLi9kYi9tb2RlbHNcIjtcbmltcG9ydCB7IGdldEN1YmlzdENvbmZpZyB9IGZyb20gXCIuLi9kYi9kYkZ1bmN0aW9uc1wiO1xuY29uc3QgZW52OiBhbnkgPSB7XG4gIFNpZ25lckFwaVJvb3Q6IHByb2Nlc3MuZW52W1wiQ1NfQVBJX1JPT1RcIl0gPz8gXCJodHRwczovL2dhbW1hLnNpZ25lci5jdWJpc3QuZGV2XCJcbn07XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cmFuc2ZlclNQTFRva2VuKFxuICBzZW5kZXJXYWxsZXRBZGRyZXNzOiBzdHJpbmcsXG4gIHJlY2VpdmVyV2FsbGV0QWRkcmVzczogc3RyaW5nLFxuICBhbW91bnQ6IG51bWJlcixcbiAgZGVjaW1hbFByZWNpc2lvbjogbnVtYmVyLFxuICBvaWRjVG9rZW46IHN0cmluZyxcbiAgY2hhaW5UeXBlOiBzdHJpbmcsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICB0ZW5hbnQ6IHRlbmFudCxcbiAgY3ViaXN0T3JnSWQ6IHN0cmluZ1xuKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IGdldFNvbENvbm5lY3Rpb24oKTtcblxuICAgIC8vIDEuIENvbGxlY3QgdmFsdWVzIGZyb20gZXZlbnRzXG4gICAgY29uc3QgbWludEFkZHJlc3MgPSBuZXcgUHVibGljS2V5KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgLy9sZXQgc2VuZGluZ0Ftb3VudCA9IHBhcnNlRmxvYXQoYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgIGNvbnNvbGUubG9nKFwiZGVjaW1hbFByZWNpc2lvblwiLCBkZWNpbWFsUHJlY2lzaW9uKTtcbiAgICBsZXQgTEFNUE9SVFNfUEVSX1NQTFRPS0VOID0gMTAgKiogZGVjaW1hbFByZWNpc2lvbjtcbiAgICBjb25zb2xlLmxvZyhcIkxBTVBPUlRTX1BFUl9TUExUT0tFTlwiLCBMQU1QT1JUU19QRVJfU1BMVE9LRU4pO1xuXG4gICAgY29uc3Qgc2VuZGluZ0Ftb3VudCA9IGFtb3VudCAqIExBTVBPUlRTX1BFUl9TUExUT0tFTjtcbiAgICBjb25zb2xlLmxvZyhcIlNlbmRpbmcgQW1vdW50XCIsIHNlbmRpbmdBbW91bnQpO1xuICAgIGNvbnNvbGUubG9nKFwiQW1vdW50XCIsIGFtb3VudCk7XG5cbiAgICBjb25zdCByZWNpcGllbnRQdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KHJlY2VpdmVyV2FsbGV0QWRkcmVzcyk7XG5cbiAgICAvLyAyLiBHZXQgdGhlIG9pZGNDbGllbnQga2V5IGZyb20gb2lkY1Rva2VuXG4gICAgY29uc3Qgb2lkY0NsaWVudCA9IGF3YWl0IG9pZGNMb2dpbihlbnYsIGN1YmlzdE9yZ0lkLCBvaWRjVG9rZW4sIFtcInNpZ246KlwiXSk7XG4gICAgaWYgKCFvaWRjQ2xpZW50KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cnhIYXNoOiBudWxsLFxuICAgICAgICBlcnJvcjogXCJQbGVhc2Ugc2VuZCBhIHZhbGlkIGlkZW50aXR5IHRva2VuIGZvciB2ZXJpZmljYXRpb25cIlxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBjdWJpc3RDb25maWcgPSBhd2FpdCBnZXRDdWJpc3RDb25maWcodGVuYW50LmlkKTtcbiAgICBpZiAoY3ViaXN0Q29uZmlnID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBudWxsLFxuICAgICAgICBlcnJvcjogXCJDdWJpc3QgQ29uZmlndXJhdGlvbiBub3QgZm91bmQgZm9yIHRoZSBnaXZlbiB0ZW5hbnRcIlxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IGF3YWl0IG9pZGNDbGllbnQuc2Vzc2lvbktleXMoKTtcbiAgICBjb25zdCBzZW5kZXJLZXkgPSBrZXlzLmZpbHRlcigoa2V5OiBjcy5LZXkpID0+IGtleS5tYXRlcmlhbElkID09PSBzZW5kZXJXYWxsZXRBZGRyZXNzKVswXTtcblxuICAgIGNvbnN0IHNlbmRlclB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkoc2VuZGVyS2V5Lm1hdGVyaWFsSWQpO1xuXG4gICAgLy8gMy4gR2V0IHRoZSBwYXllciBrZXlcbiAgICBjb25zdCBwYXllcktleSA9IGF3YWl0IGdldFBheWVyQ3NTaWduZXJLZXkoY2hhaW5UeXBlLCB0ZW5hbnQuaWQpO1xuICAgIGlmIChwYXllcktleS5rZXkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJ4SGFzaDogbnVsbCxcbiAgICAgICAgZXJyb3I6IHBheWVyS2V5LmVycm9yXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwYXllclB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXkocGF5ZXJLZXkua2V5Lm1hdGVyaWFsSWQpO1xuICAgIC8vQ2hlY2sgc29sIGJhbGFuY2Ugb24gcGF5ZXIgYWRkcmVzc1xuICAgIGNvbnN0IHBheWVyU29sQmFsYW5jZSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QmFsYW5jZShwYXllclB1YmxpY0tleSk7XG4gICAgaWYgKHBheWVyU29sQmFsYW5jZSA8IDAuMDUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyeEhhc2g6IG51bGwsXG4gICAgICAgIGVycm9yOiBcIkluc3VmZmljaWVudCBiYWxhbmNlIGluIHBheWVyIGFjY291bnRcIlxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gNC4gR2V0IG9yIGNyZWF0ZSB0aGUgYXNzb2NpYXRlZCB0b2tlbiBhY2NvdW50cyBmb3IgdGhlIHNlbmRlciBhbmQgcmVjaXBpZW50XG4gICAgY29uc3Qgc2VuZGVyVG9rZW5BY2NvdW50ID0gYXdhaXQgZ2V0T3JDcmVhdGVBc3NvY2lhdGVkVG9rZW5BY2NvdW50KGNvbm5lY3Rpb24sIHBheWVyS2V5LmtleSwgbWludEFkZHJlc3MsIHNlbmRlclB1YmxpY0tleSk7XG5cbiAgICBjb25zdCByZWNpcGllbnRUb2tlbkFjY291bnQgPSBhd2FpdCBnZXRPckNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnQoY29ubmVjdGlvbiwgcGF5ZXJLZXkua2V5LCBtaW50QWRkcmVzcywgcmVjaXBpZW50UHVibGljS2V5KTtcblxuICAgIC8vIDUuIENyZWF0ZSBhIHRyYW5zYWN0aW9uIHRvIHRyYW5zZmVyIHRva2Vuc1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKFxuICAgICAgY3JlYXRlVHJhbnNmZXJJbnN0cnVjdGlvbihcbiAgICAgICAgc2VuZGVyVG9rZW5BY2NvdW50LmFkZHJlc3MsXG4gICAgICAgIHJlY2lwaWVudFRva2VuQWNjb3VudC5hZGRyZXNzLFxuICAgICAgICBzZW5kZXJQdWJsaWNLZXksXG4gICAgICAgIHNlbmRpbmdBbW91bnQgLy8gQW1vdW50IG9mIHRva2VucyB0byB0cmFuc2ZlciAoaW4gc21hbGxlc3QgdW5pdCBvZiB0aGUgdG9rZW4sIGUuZy4sIGZvciBTUEwgdG9rZW5zIHdpdGggNiBkZWNpbWFscywgMWU2IHJlcHJlc2VudHMgMSB0b2tlbilcbiAgICAgIClcbiAgICApO1xuXG4gICAgLy8gNi5TaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBzZW5kZXIncyBrZXlwYWlyLFNldCB0aGUgZmVlIHBheWVyIHRvIHRoZSBwYXllcidzIHB1YmxpYyBrZXlcbiAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHBheWVyUHVibGljS2V5O1xuXG4gICAgLy8gNy5TcGVjaWZ5IHRoZSByZWNlbnQgYmxvY2toYXNoXG4gICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UmVjZW50QmxvY2toYXNoKCk7XG4gICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuXG4gICAgLy8gOC5TaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoIHBheWVyXG4gICAgY29uc3QgYmFzZTY0UGF5ZXIgPSB0cmFuc2FjdGlvbi5zZXJpYWxpemVNZXNzYWdlKCkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgLy8gc2lnbiB1c2luZyB0aGUgd2VsbC10eXBlZCBzb2xhbmEgZW5kIHBvaW50ICh3aGljaCByZXF1aXJlcyBhIGJhc2U2NCBzZXJpYWxpemVkIE1lc3NhZ2UpXG4gICAgY29uc3QgcmVzcFBheWVyID0gYXdhaXQgcGF5ZXJLZXkua2V5LnNpZ25Tb2xhbmEoeyBtZXNzYWdlX2Jhc2U2NDogYmFzZTY0UGF5ZXIgfSk7XG4gICAgY29uc3Qgc2lnUGF5ZXIgPSByZXNwUGF5ZXIuZGF0YSgpLnNpZ25hdHVyZTtcbiAgICBjb25zdCBzaWdCeXRlc1BheWVyID0gQnVmZmVyLmZyb20oc2lnUGF5ZXIuc2xpY2UoMiksIFwiaGV4XCIpO1xuICAgIHRyYW5zYWN0aW9uLmFkZFNpZ25hdHVyZShwYXllclB1YmxpY0tleSwgc2lnQnl0ZXNQYXllcik7XG5cbiAgICAvLyA5LlNpZ24gdGhlIHRyYW5zYWN0aW9uIHdpdGggc2VuZGVyXG4gICAgY29uc3QgYmFzZTY0U2VuZGVyID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplTWVzc2FnZSgpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIC8vIHNpZ24gdXNpbmcgdGhlIHdlbGwtdHlwZWQgc29sYW5hIGVuZCBwb2ludCAod2hpY2ggcmVxdWlyZXMgYSBiYXNlNjQgc2VyaWFsaXplZCBNZXNzYWdlKVxuICAgIGNvbnN0IHJlc3BTZW5kZXIgPSBhd2FpdCBzZW5kZXJLZXkuc2lnblNvbGFuYSh7IG1lc3NhZ2VfYmFzZTY0OiBiYXNlNjRTZW5kZXIgfSk7XG4gICAgY29uc3Qgc2lnU2VuZGVyID0gcmVzcFNlbmRlci5kYXRhKCkuc2lnbmF0dXJlO1xuICAgIGNvbnN0IHNpZ0J5dGVzU2VuZGVyID0gQnVmZmVyLmZyb20oc2lnU2VuZGVyLnNsaWNlKDIpLCBcImhleFwiKTtcbiAgICB0cmFuc2FjdGlvbi5hZGRTaWduYXR1cmUoc2VuZGVyUHVibGljS2V5LCBzaWdCeXRlc1NlbmRlcik7XG4gICAgY29uc29sZS5sb2coXCJUcmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG5cbiAgICAvLyAxMC5TZW5kIHRoZSB0cmFuc2FjdGlvblxuXG4gICAgY29uc3QgdHhIYXNoID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24uc2VyaWFsaXplKCkpO1xuICAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHR4SGFzaCk7XG5cbiAgICBjb25zb2xlLmxvZyhgdHhIYXNoOiAke3R4SGFzaH1gKTtcbiAgICByZXR1cm4geyB0cnhIYXNoOiB0eEhhc2gsIGVycm9yOiBudWxsIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4geyB0cnhIYXNoOiBudWxsLCBlcnJvcjogZSB9O1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFzc29jaWF0ZWQgdG9rZW4gYWNjb3VudCBmb3IgYSBnaXZlbiBtaW50IGFuZCBvd25lclxuICogQHBhcmFtIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBtaW50XG4gKiBAcGFyYW0gb3duZXJcbiAqIEBwYXJhbSBhbGxvd093bmVyT2ZmQ3VydmVcbiAqIEBwYXJhbSBwYXllcktleVxuICogQHBhcmFtIHByb2dyYW1JZFxuICogQHBhcmFtIGFzc29jaWF0ZWRUb2tlblByb2dyYW1JZFxuICovXG5jb25zdCBjcmVhdGVBc3NvY2lhdGVkVG9rZW5BY2NvdW50ID0gYXN5bmMgKFxuICBjb25uZWN0aW9uOiBDb25uZWN0aW9uLFxuICBtaW50OiBQdWJsaWNLZXksXG4gIG93bmVyOiBQdWJsaWNLZXksXG4gIGFsbG93T3duZXJPZmZDdXJ2ZSA9IGZhbHNlLFxuICBwYXllcktleTogY3MuS2V5LFxuICBwcm9ncmFtSWQgPSBUT0tFTl9QUk9HUkFNX0lELFxuICBhc3NvY2lhdGVkVG9rZW5Qcm9ncmFtSWQgPSBBU1NPQ0lBVEVEX1RPS0VOX1BST0dSQU1fSURcbikgPT4ge1xuICBjb25zdCBhc3NvY2lhdGVkVG9rZW4gPSBnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzU3luYyhtaW50LCBvd25lciwgYWxsb3dPd25lck9mZkN1cnZlLCBwcm9ncmFtSWQsIGFzc29jaWF0ZWRUb2tlblByb2dyYW1JZCk7XG4gIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKFxuICAgIGNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnRJbnN0cnVjdGlvbihcbiAgICAgIG5ldyBQdWJsaWNLZXkocGF5ZXJLZXkubWF0ZXJpYWxJZCksXG4gICAgICBhc3NvY2lhdGVkVG9rZW4sXG4gICAgICBvd25lcixcbiAgICAgIG1pbnQsXG4gICAgICBwcm9ncmFtSWQsXG4gICAgICBhc3NvY2lhdGVkVG9rZW5Qcm9ncmFtSWRcbiAgICApXG4gICk7XG5cbiAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBuZXcgUHVibGljS2V5KHBheWVyS2V5Lm1hdGVyaWFsSWQpO1xuICBjb25zdCB7IGJsb2NraGFzaCB9ID0gYXdhaXQgY29ubmVjdGlvbi5nZXRSZWNlbnRCbG9ja2hhc2goKTtcbiAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuICBjb25zdCBiYXNlNjQgPSB0cmFuc2FjdGlvbi5zZXJpYWxpemVNZXNzYWdlKCkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gIGNvbnN0IHJlc3AgPSBhd2FpdCBwYXllcktleS5zaWduU29sYW5hKHsgbWVzc2FnZV9iYXNlNjQ6IGJhc2U2NCB9KTtcbiAgY29uc3Qgc2lnID0gcmVzcC5kYXRhKCkuc2lnbmF0dXJlO1xuICBjb25zdCBzaWdCeXRlcyA9IEJ1ZmZlci5mcm9tKHNpZy5zbGljZSgyKSwgXCJoZXhcIik7XG4gIHRyYW5zYWN0aW9uLmFkZFNpZ25hdHVyZShuZXcgUHVibGljS2V5KHBheWVyS2V5Lm1hdGVyaWFsSWQpLCBzaWdCeXRlcyk7XG5cbiAgY29uc3QgdHhIYXNoID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24uc2VyaWFsaXplKCkpO1xuICBjb25zb2xlLmxvZyhgdHhIYXNoOiAke3R4SGFzaH1gKTtcbn07XG5cbi8qKlxuICogR2V0IG9yIGNyZWF0ZSBhbiBhc3NvY2lhdGVkIHRva2VuIGFjY291bnQgZm9yIGEgZ2l2ZW4gbWludCBhbmQgb3duZXJcbiAqIEBwYXJhbSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gcGF5ZXJcbiAqIEBwYXJhbSBtaW50XG4gKiBAcGFyYW0gb3duZXJcbiAqIEBwYXJhbSBhbGxvd093bmVyT2ZmQ3VydmVcbiAqIEBwYXJhbSBjb21taXRtZW50XG4gKiBAcGFyYW0gcHJvZ3JhbUlkXG4gKiBAcGFyYW0gYXNzb2NpYXRlZFRva2VuUHJvZ3JhbUlkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPckNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnQoXG4gIGNvbm5lY3Rpb246IENvbm5lY3Rpb24sXG4gIHBheWVyOiBjcy5LZXksXG4gIG1pbnQ6IFB1YmxpY0tleSxcbiAgb3duZXI6IFB1YmxpY0tleSxcbiAgYWxsb3dPd25lck9mZkN1cnZlID0gZmFsc2UsXG4gIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuICBwcm9ncmFtSWQgPSBUT0tFTl9QUk9HUkFNX0lELFxuICBhc3NvY2lhdGVkVG9rZW5Qcm9ncmFtSWQgPSBBU1NPQ0lBVEVEX1RPS0VOX1BST0dSQU1fSURcbik6IFByb21pc2U8QWNjb3VudD4ge1xuICBjb25zdCBhc3NvY2lhdGVkVG9rZW4gPSBnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzU3luYyhtaW50LCBvd25lciwgYWxsb3dPd25lck9mZkN1cnZlLCBwcm9ncmFtSWQsIGFzc29jaWF0ZWRUb2tlblByb2dyYW1JZCk7XG5cbiAgLy8gVGhpcyBpcyB0aGUgb3B0aW1hbCBsb2dpYywgY29uc2lkZXJpbmcgVFggZmVlLCBjbGllbnQtc2lkZSBjb21wdXRhdGlvbiwgUlBDIHJvdW5kdHJpcHMgYW5kIGd1YXJhbnRlZWQgaWRlbXBvdGVudC5cbiAgLy8gU2FkbHkgd2UgY2FuJ3QgZG8gdGhpcyBhdG9taWNhbGx5LlxuICBsZXQgYWNjb3VudDogQWNjb3VudDtcbiAgdHJ5IHtcbiAgICBhY2NvdW50ID0gYXdhaXQgZ2V0QWNjb3VudChjb25uZWN0aW9uLCBhc3NvY2lhdGVkVG9rZW4sIGNvbW1pdG1lbnQsIHByb2dyYW1JZCk7XG4gIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG4gICAgLy8gVG9rZW5BY2NvdW50Tm90Rm91bmRFcnJvciBjYW4gYmUgcG9zc2libGUgaWYgdGhlIGFzc29jaWF0ZWQgYWRkcmVzcyBoYXMgYWxyZWFkeSByZWNlaXZlZCBzb21lIGxhbXBvcnRzLFxuICAgIC8vIGJlY29taW5nIGEgc3lzdGVtIGFjY291bnQuIEFzc3VtaW5nIHByb2dyYW0gZGVyaXZlZCBhZGRyZXNzaW5nIGlzIHNhZmUsIHRoaXMgaXMgdGhlIG9ubHkgY2FzZSBmb3IgdGhlXG4gICAgLy8gVG9rZW5JbnZhbGlkQWNjb3VudE93bmVyRXJyb3IgaW4gdGhpcyBjb2RlIHBhdGguXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVG9rZW5BY2NvdW50Tm90Rm91bmRFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIFRva2VuSW52YWxpZEFjY291bnRPd25lckVycm9yKSB7XG4gICAgICAvLyBBcyB0aGlzIGlzbid0IGF0b21pYywgaXQncyBwb3NzaWJsZSBvdGhlcnMgY2FuIGNyZWF0ZSBhc3NvY2lhdGVkIGFjY291bnRzIG1lYW53aGlsZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnQoY29ubmVjdGlvbiwgbWludCwgb3duZXIsIGZhbHNlLCBwYXllcik7XG4gICAgICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgICAgICAvLyBJZ25vcmUgYWxsIGVycm9yczsgZm9yIG5vdyB0aGVyZSBpcyBubyBBUEktY29tcGF0aWJsZSB3YXkgdG8gc2VsZWN0aXZlbHkgaWdub3JlIHRoZSBleHBlY3RlZFxuICAgICAgICAvLyBpbnN0cnVjdGlvbiBlcnJvciBpZiB0aGUgYXNzb2NpYXRlZCBhY2NvdW50IGV4aXN0cyBhbHJlYWR5LlxuICAgICAgfVxuXG4gICAgICAvLyBOb3cgdGhpcyBzaG91bGQgYWx3YXlzIHN1Y2NlZWRcbiAgICAgIGFjY291bnQgPSBhd2FpdCBnZXRBY2NvdW50KGNvbm5lY3Rpb24sIGFzc29jaWF0ZWRUb2tlbiwgY29tbWl0bWVudCwgcHJvZ3JhbUlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFhY2NvdW50Lm1pbnQuZXF1YWxzKG1pbnQpKSB0aHJvdyBuZXcgVG9rZW5JbnZhbGlkTWludEVycm9yKCk7XG4gIGlmICghYWNjb3VudC5vd25lci5lcXVhbHMob3duZXIpKSB0aHJvdyBuZXcgVG9rZW5JbnZhbGlkT3duZXJFcnJvcigpO1xuXG4gIHJldHVybiBhY2NvdW50O1xufVxuIl19