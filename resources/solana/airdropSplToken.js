"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.airdropSPLToken = airdropSPLToken;
exports.getOrCreateAssociatedTokenAccountForKey = getOrCreateAssociatedTokenAccountForKey;
const web3_js_1 = require("@solana/web3.js");
const spl_token_1 = require("@solana/spl-token");
const CubeSignerClient_1 = require("../cubist/CubeSignerClient");
const solanaFunctions_1 = require("./solanaFunctions");
const dbFunctions_1 = require("../db/dbFunctions");
const env = {
    SignerApiRoot: process.env["CS_API_ROOT"] ?? "https://gamma.signer.cubist.dev"
};
async function airdropSPLToken(receiverWalletAddress, amount, decimalPrecision, chainType, contractAddress, tenant) {
    try {
        console.log("Receiver Wallet Address", receiverWalletAddress);
        const connection = await (0, solanaFunctions_1.getSolConnection)();
        // 1. Collect values from events
        const mint = new web3_js_1.PublicKey(contractAddress);
        //let sendingAmount = parseFloat(amount.toString());
        console.log("decimalPrecision", decimalPrecision);
        let LAMPORTS_PER_SPLTOKEN = 10 ** decimalPrecision;
        console.log("LAMPORTS_PER_SPLTOKEN", LAMPORTS_PER_SPLTOKEN);
        const sendingAmount = amount * LAMPORTS_PER_SPLTOKEN;
        console.log("Sending Amount", sendingAmount);
        console.log("Amount", amount);
        const cubistConfig = await (0, dbFunctions_1.getCubistConfig)(tenant.id);
        if (cubistConfig == null) {
            return {
                transaction: null,
                error: "Cubist Configuration not found for the given tenant"
            };
        }
        // 3. Get the payer key
        const payerKey = await (0, CubeSignerClient_1.getPayerCsSignerKey)(chainType, tenant.id);
        if (payerKey.key == null) {
            return {
                trxHash: null,
                error: payerKey.error
            };
        }
        const payerPublicKey = new web3_js_1.PublicKey(payerKey.key.materialId);
        console.log("Payer Public Key", payerPublicKey, payerKey.key.materialId);
        //Check sol balance on payer address
        const payerSolBalance = await connection.getBalance(payerPublicKey);
        if (payerSolBalance < 0.05) {
            return {
                trxHash: null,
                error: "Insufficient balance in payer account"
            };
        }
        const fromTokenAccount = await getOrCreateAssociatedTokenAccountForKey(connection, payerKey.key, mint, payerPublicKey);
        // Get the wallet's associated token account for the given mint
        console.log("From Token Account", fromTokenAccount);
        const instructions = [];
        for (const recipient of receiverWalletAddress) {
            // const toWallet = new PublicKey(receiverWalletAddress[0].walletaddress);
            const toWallet = new web3_js_1.PublicKey(recipient.walletaddress);
            const toTokenAccount = await getOrCreateAssociatedTokenAccountForKey(connection, payerKey.key, mint, toWallet);
            //  const toTokenAccount = await getOrCreateAssociatedAccountInfo(recipient.walletaddress);
            // const toTokenAccount = await getOrCreateRecipientAssociatedTokenAccount(
            //   connection, toWallet, mint, toWallet
            // );
            // console.log("To Token Account", toTokenAccount);
            instructions.push((0, spl_token_1.createTransferInstruction)(fromTokenAccount.address, toTokenAccount.address, payerPublicKey, sendingAmount, [], spl_token_1.TOKEN_PROGRAM_ID));
        }
        // 5. Create a transaction to transfer tokens
        const transaction = new web3_js_1.Transaction().add(...instructions);
        console.log("instructions", instructions);
        // 6.Sign the transaction with the sender's keypair,Set the fee payer to the payer's public key
        transaction.feePayer = payerPublicKey;
        // 7.Specify the recent blockhash
        const { blockhash } = await connection.getRecentBlockhash();
        transaction.recentBlockhash = blockhash;
        // 8.Sign the transaction with payer
        const base64Payer = transaction.serializeMessage().toString("base64");
        // sign using the well-typed solana end point (which requires a base64 serialized Message)
        const respPayer = await payerKey.key.signSolana({ message_base64: base64Payer });
        const sigPayer = respPayer.data().signature;
        const sigBytesPayer = Buffer.from(sigPayer.slice(2), "hex");
        transaction.addSignature(payerPublicKey, sigBytesPayer);
        // // 9.Sign the transaction with sender
        // const base64Sender = transaction.serializeMessage().toString("base64");
        // // sign using the well-typed solana end point (which requires a base64 serialized Message)
        // const respSender = await payerKey.key.signSolana({ message_base64: base64Sender });
        // const sigSender = respSender.data().signature;
        // const sigBytesSender = Buffer.from(sigSender.slice(2), "hex");
        // transaction.addSignature(payerPublicKey, sigBytesSender);
        console.log("Transaction", transaction);
        // 10.Send the transaction
        const txHash = await connection.sendRawTransaction(transaction.serialize());
        await connection.confirmTransaction(txHash);
        console.log(`txHash: ${txHash}`);
        return { trxHash: txHash, error: null };
    }
    catch (e) {
        console.log("from airdrop fun", e);
        return { trxHash: null, error: e };
    }
}
/**
 * Get or create an associated token account for a given mint and owner
 * @param connection
 * @param payer
 * @param mint
 * @param owner
 * @param allowOwnerOffCurve
 * @param commitment
 * @param programId
 * @param associatedTokenProgramId
 */
async function getOrCreateAssociatedTokenAccountForKey(connection, payer, mint, owner, allowOwnerOffCurve = false, commitment, programId = spl_token_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID) {
    const associatedToken = (0, spl_token_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
    console.log("associatedToken", associatedToken);
    // This is the optimal logic, considering TX fee, client-side computation, RPC roundtrips and guaranteed idempotent.
    // Sadly we can't do this atomically.
    let account;
    try {
        account = await (0, spl_token_1.getAccount)(connection, associatedToken, commitment, programId);
        console.log("account", account);
    }
    catch (error) {
        // TokenAccountNotFoundError can be possible if the associated address has already received some lamports,
        // becoming a system account. Assuming program derived addressing is safe, this is the only case for the
        // TokenInvalidAccountOwnerError in this code path.
        if (error instanceof spl_token_1.TokenAccountNotFoundError || error instanceof spl_token_1.TokenInvalidAccountOwnerError) {
            // As this isn't atomic, it's possible others can create associated accounts meanwhile.
            try {
                await createAssociatedTokenAccount(connection, mint, owner, false, payer);
            }
            catch (error) {
                console.log("error from catch1", error);
                // Ignore all errors; for now there is no API-compatible way to selectively ignore the expected
                // instruction error if the associated account exists already.
            }
            // Now this should always succeed
            await delay(1000);
            account = await (0, spl_token_1.getAccount)(connection, associatedToken, commitment, programId);
            console.log("accountfromcatch", account);
        }
        else {
            console.log("error from else", error);
            throw error;
        }
    }
    if (!account.mint.equals(mint))
        throw new spl_token_1.TokenInvalidMintError();
    if (!account.owner.equals(owner))
        throw new spl_token_1.TokenInvalidOwnerError();
    return account;
}
function delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
/**
 * Create an associated token account for a given mint and owner
 * @param connection
 * @param mint
 * @param owner
 * @param allowOwnerOffCurve
 * @param payerKey
 * @param programId
 * @param associatedTokenProgramId
 */
const createAssociatedTokenAccount = async (connection, mint, owner, allowOwnerOffCurve = false, payerKey, programId = spl_token_1.TOKEN_PROGRAM_ID, associatedTokenProgramId = spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID) => {
    const associatedToken = (0, spl_token_1.getAssociatedTokenAddressSync)(mint, owner, allowOwnerOffCurve, programId, associatedTokenProgramId);
    const transaction = new web3_js_1.Transaction().add((0, spl_token_1.createAssociatedTokenAccountInstruction)(new web3_js_1.PublicKey(payerKey.materialId), associatedToken, owner, mint, programId, associatedTokenProgramId));
    transaction.feePayer = new web3_js_1.PublicKey(payerKey.materialId);
    const { blockhash } = await connection.getRecentBlockhash();
    transaction.recentBlockhash = blockhash;
    const base64 = transaction.serializeMessage().toString("base64");
    const resp = await payerKey.signSolana({ message_base64: base64 });
    const sig = resp.data().signature;
    const sigBytes = Buffer.from(sig.slice(2), "hex");
    transaction.addSignature(new web3_js_1.PublicKey(payerKey.materialId), sigBytes);
    const txHash = await connection.sendRawTransaction(transaction.serialize());
    console.log(`txHashCreateToken: ${txHash}`);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWlyZHJvcFNwbFRva2VuLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYWlyZHJvcFNwbFRva2VuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBeUJBLDBDQWlIQztBQWFELDBGQWdEQztBQXZNRCw2Q0FBc0Y7QUFDdEYsaURBYTJCO0FBRzNCLGlFQUE0RTtBQUM1RSx1REFBcUQ7QUFFckQsbURBQW9EO0FBQ3BELE1BQU0sR0FBRyxHQUFRO0lBQ2YsYUFBYSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLElBQUksaUNBQWlDO0NBQy9FLENBQUM7QUFFSyxLQUFLLFVBQVUsZUFBZSxDQUNuQyxxQkFBNEIsRUFDNUIsTUFBYyxFQUNkLGdCQUF3QixFQUN4QixTQUFpQixFQUNqQixlQUF1QixFQUN2QixNQUFXO0lBRVgsSUFBSSxDQUFDO1FBQ0gsT0FBTyxDQUFDLEdBQUcsQ0FBQyx5QkFBeUIsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO1FBQzlELE1BQU0sVUFBVSxHQUFHLE1BQU0sSUFBQSxrQ0FBZ0IsR0FBRSxDQUFDO1FBRTVDLGdDQUFnQztRQUNoQyxNQUFNLElBQUksR0FBRyxJQUFJLG1CQUFTLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDNUMsb0RBQW9EO1FBQ3BELE9BQU8sQ0FBQyxHQUFHLENBQUMsa0JBQWtCLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztRQUNsRCxJQUFJLHFCQUFxQixHQUFHLEVBQUUsSUFBSSxnQkFBZ0IsQ0FBQztRQUNuRCxPQUFPLENBQUMsR0FBRyxDQUFDLHVCQUF1QixFQUFFLHFCQUFxQixDQUFDLENBQUM7UUFFNUQsTUFBTSxhQUFhLEdBQUcsTUFBTSxHQUFHLHFCQUFxQixDQUFDO1FBQ3JELE9BQU8sQ0FBQyxHQUFHLENBQUMsZ0JBQWdCLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDN0MsT0FBTyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFOUIsTUFBTSxZQUFZLEdB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LElBQUksRUFDSixTQUFTLEVBQ1Qsd0JBQXdCLENBQ3pCLENBQ0YsQ0FBQztJQUVGLFdBQVcsQ0FBQyxRQUFRLEdBQUcsSUFBSSxtQkFBUyxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUMxRCxNQUFNLEVBQUUsU0FBUyxFQUFFLEdBQUcsTUFBTSxVQUFVLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUM1RCxXQUFXLENBQUMsZUFBZSxHQUFHLFNBQVMsQ0FBQztJQUN4QyxNQUFNLE1BQU0sR0FBRyxXQUFXLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDakUsTUFBTSxJQUFJLEdBQUcsTUFBTSxRQUFRLENBQUMsVUFBVSxDQUFDLEVBQUUsY0FBYyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDbkUsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLFNBQVMsQ0FBQztJQUNsQyxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDbEQsV0FBVyxDQUFDLFlBQVksQ0FBQyxJQUFJLG1CQUFTLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBRXZFLE1BQU0sTUFBTSxHQUFHLE1BQU0sVUFBVSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQzVFLE9BQU8sQ0FBQyxHQUFHLENBQUMsc0JBQXNCLE1BQU0sRUFBRSxDQUFDLENBQUM7QUFDOUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29ubmVjdGlvbiwgVHJhbnNhY3Rpb24sIFB1YmxpY0tleSwgdHlwZSBDb21taXRtZW50IH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuaW1wb3J0IHtcbiAgQVNTT0NJQVRFRF9UT0tFTl9QUk9HUkFNX0lELFxuICBjcmVhdGVBc3NvY2lhdGVkVG9rZW5BY2NvdW50SW5zdHJ1Y3Rpb24sXG4gIGNyZWF0ZVRyYW5zZmVySW5zdHJ1Y3Rpb24sXG4gIGdldEFzc29jaWF0ZWRUb2tlbkFkZHJlc3NTeW5jLFxuICBUT0tFTl9QUk9HUkFNX0lELFxuICBUb2tlbkFjY291bnROb3RGb3VuZEVycm9yLFxuICBUb2tlbkludmFsaWRBY2NvdW50T3duZXJFcnJvcixcbiAgVG9rZW5JbnZhbGlkTWludEVycm9yLFxuICBUb2tlbkludmFsaWRPd25lckVycm9yLFxuICBBY2NvdW50LFxuICBnZXRBY2NvdW50LFxuICBnZXRPckNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnRcbn0gZnJvbSBcIkBzb2xhbmEvc3BsLXRva2VuXCI7XG5cbmltcG9ydCAqIGFzIGNzIGZyb20gXCJAY3ViaXN0LWxhYnMvY3ViZXNpZ25lci1zZGtcIjtcbmltcG9ydCB7IG9pZGNMb2dpbiwgZ2V0UGF5ZXJDc1NpZ25lcktleSB9IGZyb20gXCIuLi9jdWJpc3QvQ3ViZVNpZ25lckNsaWVudFwiO1xuaW1wb3J0IHsgZ2V0U29sQ29ubmVjdGlvbiB9IGZyb20gXCIuL3NvbGFuYUZ1bmN0aW9uc1wiO1xuaW1wb3J0IHsgdGVuYW50IH0gZnJvbSBcIi4uL2RiL21vZGVsc1wiO1xuaW1wb3J0IHsgZ2V0Q3ViaXN0Q29uZmlnIH0gZnJvbSBcIi4uL2RiL2RiRnVuY3Rpb25zXCI7XG5jb25zdCBlbnY6IGFueSA9IHtcbiAgU2lnbmVyQXBpUm9vdDogcHJvY2Vzcy5lbnZbXCJDU19BUElfUk9PVFwiXSA/PyBcImh0dHBzOi8vZ2FtbWEuc2lnbmVyLmN1YmlzdC5kZXZcIlxufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFpcmRyb3BTUExUb2tlbihcbiAgcmVjZWl2ZXJXYWxsZXRBZGRyZXNzOiBhbnlbXSxcbiAgYW1vdW50OiBudW1iZXIsXG4gIGRlY2ltYWxQcmVjaXNpb246IG51bWJlcixcbiAgY2hhaW5UeXBlOiBzdHJpbmcsXG4gIGNvbnRyYWN0QWRkcmVzczogc3RyaW5nLFxuICB0ZW5hbnQ6IGFueVxuKSB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coXCJSZWNlaXZlciBXYWxsZXQgQWRkcmVzc1wiLCByZWNlaXZlcldhbGxldEFkZHJlc3MpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBhd2FpdCBnZXRTb2xDb25uZWN0aW9uKCk7XG5cbiAgICAvLyAxLiBDb2xsZWN0IHZhbHVlcyBmcm9tIGV2ZW50c1xuICAgIGNvbnN0IG1pbnQgPSBuZXcgUHVibGljS2V5KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgLy9sZXQgc2VuZGluZ0Ftb3VudCA9IHBhcnNlRmxvYXQoYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgIGNvbnNvbGUubG9nKFwiZGVjaW1hbFByZWNpc2lvblwiLCBkZWNpbWFsUHJlY2lzaW9uKTtcbiAgICBsZXQgTEFNUE9SVFNfUEVSX1NQTFRPS0VOID0gMTAgKiogZGVjaW1hbFByZWNpc2lvbjtcbiAgICBjb25zb2xlLmxvZyhcIkxBTVBPUlRTX1BFUl9TUExUT0tFTlwiLCBMQU1QT1JUU19QRVJfU1BMVE9LRU4pO1xuXG4gICAgY29uc3Qgc2VuZGluZ0Ftb3VudCA9IGFtb3VudCAqIExBTVBPUlRTX1BFUl9TUExUT0tFTjtcbiAgICBjb25zb2xlLmxvZyhcIlNlbmRpbmcgQW1vdW50XCIsIHNlbmRpbmdBbW91bnQpO1xuICAgIGNvbnNvbGUubG9nKFwiQW1vdW50XCIsIGFtb3VudCk7XG5cbiAgICBjb25zdCBjdWJpc3RDb25maWcgPSBhd2FpdCBnZXRDdWJpc3RDb25maWcodGVuYW50LmlkKTtcbiAgICBpZiAoY3ViaXN0Q29uZmlnID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBudWxsLFxuICAgICAgICBlcnJvcjogXCJDdWJpc3QgQ29uZmlndXJhdGlvbiBub3QgZm91bmQgZm9yIHRoZSBnaXZlbiB0ZW5hbnRcIlxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyAzLiBHZXQgdGhlIHBheWVyIGtleVxuICAgIGNvbnN0IHBheWVyS2V5ID0gYXdhaXQgZ2V0UGF5ZXJDc1NpZ25lcktleShjaGFpblR5cGUsIHRlbmFudC5pZCk7XG4gICAgaWYgKHBheWVyS2V5LmtleSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cnhIYXNoOiBudWxsLFxuICAgICAgICBlcnJvcjogcGF5ZXJLZXkuZXJyb3JcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBheWVyUHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShwYXllcktleS5rZXkubWF0ZXJpYWxJZCk7XG4gICAgY29uc29sZS5sb2coXCJQYXllciBQdWJsaWMgS2V5XCIsIHBheWVyUHVibGljS2V5LCBwYXllcktleS5rZXkubWF0ZXJpYWxJZCk7XG4gICAgLy9DaGVjayBzb2wgYmFsYW5jZSBvbiBwYXllciBhZGRyZXNzXG4gICAgY29uc3QgcGF5ZXJTb2xCYWxhbmNlID0gYXdhaXQgY29ubmVjdGlvbi5nZXRCYWxhbmNlKHBheWVyUHVibGljS2V5KTtcbiAgICBpZiAocGF5ZXJTb2xCYWxhbmNlIDwgMC4wNSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJ4SGFzaDogbnVsbCxcbiAgICAgICAgZXJyb3I6IFwiSW5zdWZmaWNpZW50IGJhbGFuY2UgaW4gcGF5ZXIgYWNjb3VudFwiXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGZyb21Ub2tlbkFjY291bnQgPSBhd2FpdCBnZXRPckNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnRGb3JLZXkoY29ubmVjdGlvbiwgcGF5ZXJLZXkua2V5LCBtaW50LCBwYXllclB1YmxpY0tleSk7XG5cbiAgICAvLyBHZXQgdGhlIHdhbGxldCdzIGFzc29jaWF0ZWQgdG9rZW4gYWNjb3VudCBmb3IgdGhlIGdpdmVuIG1pbnRcblxuICAgIGNvbnNvbGUubG9nKFwiRnJvbSBUb2tlbiBBY2NvdW50XCIsIGZyb21Ub2tlbkFjY291bnQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgcmVjaXBpZW50IG9mIHJlY2VpdmVyV2FsbGV0QWRkcmVzcykge1xuICAgICAgLy8gY29uc3QgdG9XYWxsZXQgPSBuZXcgUHVibGljS2V5KHJlY2VpdmVyV2FsbGV0QWRkcmVzc1swXS53YWxsZXRhZGRyZXNzKTtcbiAgICAgIGNvbnN0IHRvV2FsbGV0ID0gbmV3IFB1YmxpY0tleShyZWNpcGllbnQud2FsbGV0YWRkcmVzcyk7XG4gICAgICBjb25zdCB0b1Rva2VuQWNjb3VudCA9IGF3YWl0IGdldE9yQ3JlYXRlQXNzb2NpYXRlZFRva2VuQWNjb3VudEZvcktleShjb25uZWN0aW9uLCBwYXllcktleS5rZXksIG1pbnQsIHRvV2FsbGV0KTtcblxuICAgICAgLy8gIGNvbnN0IHRvVG9rZW5BY2NvdW50ID0gYXdhaXQgZ2V0T3JDcmVhdGVBc3NvY2lhdGVkQWNjb3VudEluZm8ocmVjaXBpZW50LndhbGxldGFkZHJlc3MpO1xuXG4gICAgICAvLyBjb25zdCB0b1Rva2VuQWNjb3VudCA9IGF3YWl0IGdldE9yQ3JlYXRlUmVjaXBpZW50QXNzb2NpYXRlZFRva2VuQWNjb3VudChcbiAgICAgIC8vICAgY29ubmVjdGlvbiwgdG9XYWxsZXQsIG1pbnQsIHRvV2FsbGV0XG5cbiAgICAgIC8vICk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhcIlRvIFRva2VuIEFjY291bnRcIiwgdG9Ub2tlbkFjY291bnQpO1xuXG4gICAgICBpbnN0cnVjdGlvbnMucHVzaChcbiAgICAgICAgY3JlYXRlVHJhbnNmZXJJbnN0cnVjdGlvbihmcm9tVG9rZW5BY2NvdW50LmFkZHJlc3MsIHRvVG9rZW5BY2NvdW50LmFkZHJlc3MsIHBheWVyUHVibGljS2V5LCBzZW5kaW5nQW1vdW50LCBbXSwgVE9LRU5fUFJPR1JBTV9JRClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gNS4gQ3JlYXRlIGEgdHJhbnNhY3Rpb24gdG8gdHJhbnNmZXIgdG9rZW5zXG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoLi4uaW5zdHJ1Y3Rpb25zKTtcbiAgICBjb25zb2xlLmxvZyhcImluc3RydWN0aW9uc1wiLCBpbnN0cnVjdGlvbnMpO1xuXG4gICAgLy8gNi5TaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBzZW5kZXIncyBrZXlwYWlyLFNldCB0aGUgZmVlIHBheWVyIHRvIHRoZSBwYXllcidzIHB1YmxpYyBrZXlcbiAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHBheWVyUHVibGljS2V5O1xuXG4gICAgLy8gNy5TcGVjaWZ5IHRoZSByZWNlbnQgYmxvY2toYXNoXG4gICAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UmVjZW50QmxvY2toYXNoKCk7XG4gICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuXG4gICAgLy8gOC5TaWduIHRoZSB0cmFuc2FjdGlvbiB3aXRoIHBheWVyXG4gICAgY29uc3QgYmFzZTY0UGF5ZXIgPSB0cmFuc2FjdGlvbi5zZXJpYWxpemVNZXNzYWdlKCkudG9TdHJpbmcoXCJiYXNlNjRcIik7XG4gICAgLy8gc2lnbiB1c2luZyB0aGUgd2VsbC10eXBlZCBzb2xhbmEgZW5kIHBvaW50ICh3aGljaCByZXF1aXJlcyBhIGJhc2U2NCBzZXJpYWxpemVkIE1lc3NhZ2UpXG4gICAgY29uc3QgcmVzcFBheWVyID0gYXdhaXQgcGF5ZXJLZXkua2V5LnNpZ25Tb2xhbmEoeyBtZXNzYWdlX2Jhc2U2NDogYmFzZTY0UGF5ZXIgfSk7XG4gICAgY29uc3Qgc2lnUGF5ZXIgPSByZXNwUGF5ZXIuZGF0YSgpLnNpZ25hdHVyZTtcbiAgICBjb25zdCBzaWdCeXRlc1BheWVyID0gQnVmZmVyLmZyb20oc2lnUGF5ZXIuc2xpY2UoMiksIFwiaGV4XCIpO1xuICAgIHRyYW5zYWN0aW9uLmFkZFNpZ25hdHVyZShwYXllclB1YmxpY0tleSwgc2lnQnl0ZXNQYXllcik7XG5cbiAgICAvLyAvLyA5LlNpZ24gdGhlIHRyYW5zYWN0aW9uIHdpdGggc2VuZGVyXG4gICAgLy8gY29uc3QgYmFzZTY0U2VuZGVyID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplTWVzc2FnZSgpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICAgIC8vIC8vIHNpZ24gdXNpbmcgdGhlIHdlbGwtdHlwZWQgc29sYW5hIGVuZCBwb2ludCAod2hpY2ggcmVxdWlyZXMgYSBiYXNlNjQgc2VyaWFsaXplZCBNZXNzYWdlKVxuICAgIC8vIGNvbnN0IHJlc3BTZW5kZXIgPSBhd2FpdCBwYXllcktleS5rZXkuc2lnblNvbGFuYSh7IG1lc3NhZ2VfYmFzZTY0OiBiYXNlNjRTZW5kZXIgfSk7XG4gICAgLy8gY29uc3Qgc2lnU2VuZGVyID0gcmVzcFNlbmRlci5kYXRhKCkuc2lnbmF0dXJlO1xuICAgIC8vIGNvbnN0IHNpZ0J5dGVzU2VuZGVyID0gQnVmZmVyLmZyb20oc2lnU2VuZGVyLnNsaWNlKDIpLCBcImhleFwiKTtcbiAgICAvLyB0cmFuc2FjdGlvbi5hZGRTaWduYXR1cmUocGF5ZXJQdWJsaWNLZXksIHNpZ0J5dGVzU2VuZGVyKTtcbiAgICBjb25zb2xlLmxvZyhcIlRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblxuICAgIC8vIDEwLlNlbmQgdGhlIHRyYW5zYWN0aW9uXG5cbiAgICBjb25zdCB0eEhhc2ggPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbih0cmFuc2FjdGlvbi5zZXJpYWxpemUoKSk7XG4gICAgYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24odHhIYXNoKTtcblxuICAgIGNvbnNvbGUubG9nKGB0eEhhc2g6ICR7dHhIYXNofWApO1xuICAgIHJldHVybiB7IHRyeEhhc2g6IHR4SGFzaCwgZXJyb3I6IG51bGwgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUubG9nKFwiZnJvbSBhaXJkcm9wIGZ1blwiLCBlKTtcbiAgICByZXR1cm4geyB0cnhIYXNoOiBudWxsLCBlcnJvcjogZSB9O1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9yIGNyZWF0ZSBhbiBhc3NvY2lhdGVkIHRva2VuIGFjY291bnQgZm9yIGEgZ2l2ZW4gbWludCBhbmQgb3duZXJcbiAqIEBwYXJhbSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gcGF5ZXJcbiAqIEBwYXJhbSBtaW50XG4gKiBAcGFyYW0gb3duZXJcbiAqIEBwYXJhbSBhbGxvd093bmVyT2ZmQ3VydmVcbiAqIEBwYXJhbSBjb21taXRtZW50XG4gKiBAcGFyYW0gcHJvZ3JhbUlkXG4gKiBAcGFyYW0gYXNzb2NpYXRlZFRva2VuUHJvZ3JhbUlkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPckNyZWF0ZUFzc29jaWF0ZWRUb2tlbkFjY291bnRGb3JLZXkoXG4gIGNvbm5lY3Rpb246IENvbm5lY3Rpb24sXG4gIHBheWVyOiBjcy5LZXksXG4gIG1pbnQ6IFB1YmxpY0tleSxcbiAgb3duZXI6IFB1YmxpY0tleSxcbiAgYWxsb3dPd25lck9mZkN1cnZlID0gZmFsc2UsXG4gIGNvbW1pdG1lbnQ/OiBDb21taXRtZW50LFxuICBwcm9ncmFtSWQgPSBUT0tFTl9QUk9HUkFNX0lELFxuICBhc3NvY2lhdGVkVG9rZW5Qcm9ncmFtSWQgPSBBU1NPQ0lBVEVEX1RPS0VOX1BST0dSQU1fSURcbik6IFByb21pc2U8QWNjb3VudD4ge1xuICBjb25zdCBhc3NvY2lhdGVkVG9rZW4gPSBnZXRBc3NvY2lhdGVkVG9rZW5BZGRyZXNzU3luYyhtaW50LCBvd25lciwgYWxsb3dPd25lck9mZkN1cnZlLCBwcm9ncmFtSWQsIGFzc29jaWF0ZWRUb2tlblByb2dyYW1JZCk7XG4gIGNvbnNvbGUubG9nKFwiYXNzb2NpYXRlZFRva2VuXCIsIGFzc29jaWF0ZWRUb2tlbik7XG4gIC8vIFRoaXMgaXMgdGhlIG9wdGltYWwgbG9naWMsIGNvbnNpZGVyaW5nIFRYIGZlZSwgY2xpZW50LXNpZGUgY29tcHV0YXRpb24sIFJQQyByb3VuZHRyaXBzIGFuZCBndWFyYW50ZWVkIGlkZW1wb3RlbnQuXG4gIC8vIFNhZGx5IHdlIGNhbid0IGRvIHRoaXMgYXRvbWljYWxseS5cbiAgbGV0IGFjY291bnQ6IEFjY291bnQ7XG4gIHRyeSB7XG4gICAgYWNjb3VudCA9IGF3YWl0IGdldEFjY291bnQoY29ubmVjdGlvbiwgYXNzb2NpYXRlZFRva2VuLCBjb21taXRtZW50LCBwcm9ncmFtSWQpO1xuICAgIGNvbnNvbGUubG9nKFwiYWNjb3VudFwiLCBhY2NvdW50KTtcbiAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICAvLyBUb2tlbkFjY291bnROb3RGb3VuZEVycm9yIGNhbiBiZSBwb3NzaWJsZSBpZiB0aGUgYXNzb2NpYXRlZCBhZGRyZXNzIGhhcyBhbHJlYWR5IHJlY2VpdmVkIHNvbWUgbGFtcG9ydHMsXG4gICAgLy8gYmVjb21pbmcgYSBzeXN0ZW0gYWNjb3VudC4gQXNzdW1pbmcgcHJvZ3JhbSBkZXJpdmVkIGFkZHJlc3NpbmcgaXMgc2FmZSwgdGhpcyBpcyB0aGUgb25seSBjYXNlIGZvciB0aGVcbiAgICAvLyBUb2tlbkludmFsaWRBY2NvdW50T3duZXJFcnJvciBpbiB0aGlzIGNvZGUgcGF0aC5cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUb2tlbkFjY291bnROb3RGb3VuZEVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgVG9rZW5JbnZhbGlkQWNjb3VudE93bmVyRXJyb3IpIHtcbiAgICAgIC8vIEFzIHRoaXMgaXNuJ3QgYXRvbWljLCBpdCdzIHBvc3NpYmxlIG90aGVycyBjYW4gY3JlYXRlIGFzc29jaWF0ZWQgYWNjb3VudHMgbWVhbndoaWxlLlxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY3JlYXRlQXNzb2NpYXRlZFRva2VuQWNjb3VudChjb25uZWN0aW9uLCBtaW50LCBvd25lciwgZmFsc2UsIHBheWVyKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yOiB1bmtub3duKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZXJyb3IgZnJvbSBjYXRjaDFcIiwgZXJyb3IpO1xuICAgICAgICAvLyBJZ25vcmUgYWxsIGVycm9yczsgZm9yIG5vdyB0aGVyZSBpcyBubyBBUEktY29tcGF0aWJsZSB3YXkgdG8gc2VsZWN0aXZlbHkgaWdub3JlIHRoZSBleHBlY3RlZFxuICAgICAgICAvLyBpbnN0cnVjdGlvbiBlcnJvciBpZiB0aGUgYXNzb2NpYXRlZCBhY2NvdW50IGV4aXN0cyBhbHJlYWR5LlxuICAgICAgfVxuXG4gICAgICAvLyBOb3cgdGhpcyBzaG91bGQgYWx3YXlzIHN1Y2NlZWRcblxuICAgICAgYXdhaXQgZGVsYXkoMTAwMCk7XG4gICAgICBhY2NvdW50ID0gYXdhaXQgZ2V0QWNjb3VudChjb25uZWN0aW9uLCBhc3NvY2lhdGVkVG9rZW4sIGNvbW1pdG1lbnQsIHByb2dyYW1JZCk7XG5cbiAgICAgIGNvbnNvbGUubG9nKFwiYWNjb3VudGZyb21jYXRjaFwiLCBhY2NvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJlcnJvciBmcm9tIGVsc2VcIiwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFhY2NvdW50Lm1pbnQuZXF1YWxzKG1pbnQpKSB0aHJvdyBuZXcgVG9rZW5JbnZhbGlkTWludEVycm9yKCk7XG4gIGlmICghYWNjb3VudC5vd25lci5lcXVhbHMob3duZXIpKSB0aHJvdyBuZXcgVG9rZW5JbnZhbGlkT3duZXJFcnJvcigpO1xuXG4gIHJldHVybiBhY2NvdW50O1xufVxuXG5mdW5jdGlvbiBkZWxheShtczogbnVtYmVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBhc3NvY2lhdGVkIHRva2VuIGFjY291bnQgZm9yIGEgZ2l2ZW4gbWludCBhbmQgb3duZXJcbiAqIEBwYXJhbSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gbWludFxuICogQHBhcmFtIG93bmVyXG4gKiBAcGFyYW0gYWxsb3dPd25lck9mZkN1cnZlXG4gKiBAcGFyYW0gcGF5ZXJLZXlcbiAqIEBwYXJhbSBwcm9ncmFtSWRcbiAqIEBwYXJhbSBhc3NvY2lhdGVkVG9rZW5Qcm9ncmFtSWRcbiAqL1xuY29uc3QgY3JlYXRlQXNzb2NpYXRlZFRva2VuQWNjb3VudCA9IGFzeW5jIChcbiAgY29ubmVjdGlvbjogQ29ubmVjdGlvbixcbiAgbWludDogUHVibGljS2V5LFxuICBvd25lcjogUHVibGljS2V5LFxuICBhbGxvd093bmVyT2ZmQ3VydmUgPSBmYWxzZSxcbiAgcGF5ZXJLZXk6IGNzLktleSxcbiAgcHJvZ3JhbUlkID0gVE9LRU5fUFJPR1JBTV9JRCxcbiAgYXNzb2NpYXRlZFRva2VuUHJvZ3JhbUlkID0gQVNTT0NJQVRFRF9UT0tFTl9QUk9HUkFNX0lEXG4pID0+IHtcbiAgY29uc3QgYXNzb2NpYXRlZFRva2VuID0gZ2V0QXNzb2NpYXRlZFRva2VuQWRkcmVzc1N5bmMobWludCwgb3duZXIsIGFsbG93T3duZXJPZmZDdXJ2ZSwgcHJvZ3JhbUlkLCBhc3NvY2lhdGVkVG9rZW5Qcm9ncmFtSWQpO1xuICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChcbiAgICBjcmVhdGVBc3NvY2lhdGVkVG9rZW5BY2NvdW50SW5zdHJ1Y3Rpb24oXG4gICAgICBuZXcgUHVibGljS2V5KHBheWVyS2V5Lm1hdGVyaWFsSWQpLFxuICAgICAgYXNzb2NpYXRlZFRva2VuLFxuICAgICAgb3duZXIsXG4gICAgICBtaW50LFxuICAgICAgcHJvZ3JhbUlkLFxuICAgICAgYXNzb2NpYXRlZFRva2VuUHJvZ3JhbUlkXG4gICAgKVxuICApO1xuXG4gIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gbmV3IFB1YmxpY0tleShwYXllcktleS5tYXRlcmlhbElkKTtcbiAgY29uc3QgeyBibG9ja2hhc2ggfSA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0UmVjZW50QmxvY2toYXNoKCk7XG4gIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGJsb2NraGFzaDtcbiAgY29uc3QgYmFzZTY0ID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplTWVzc2FnZSgpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xuICBjb25zdCByZXNwID0gYXdhaXQgcGF5ZXJLZXkuc2lnblNvbGFuYSh7IG1lc3NhZ2VfYmFzZTY0OiBiYXNlNjQgfSk7XG4gIGNvbnN0IHNpZyA9IHJlc3AuZGF0YSgpLnNpZ25hdHVyZTtcbiAgY29uc3Qgc2lnQnl0ZXMgPSBCdWZmZXIuZnJvbShzaWcuc2xpY2UoMiksIFwiaGV4XCIpO1xuICB0cmFuc2FjdGlvbi5hZGRTaWduYXR1cmUobmV3IFB1YmxpY0tleShwYXllcktleS5tYXRlcmlhbElkKSwgc2lnQnl0ZXMpO1xuXG4gIGNvbnN0IHR4SGFzaCA9IGF3YWl0IGNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpKTtcbiAgY29uc29sZS5sb2coYHR4SGFzaENyZWF0ZVRva2VuOiAke3R4SGFzaH1gKTtcbn07XG4iXX0=